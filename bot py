import os
import asyncio
import time
import math
import logging
import re
import yt_dlp
import requests
import libtorrent as lt
from pathlib import Path
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup
from pyrogram.errors import MessageNotModified
import boto3
from botocore.config import Config
from botocore.exceptions import ClientError

# Import your config
from config import config

# --- LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- CONFIGURATION ---
# Cloud storage configurations
SUPPORTED_CLOUDS = {
    'wasabi': {
        'enabled': bool(config.WASABI_ACCESS_KEY),
        'client': None,
        'bucket': config.WASABI_BUCKET,
        'region': config.WASABI_REGION
    },
    'telegram': {
        'enabled': True,  # Always enabled
        'max_size': 2 * 1024 * 1024 * 1024  # 2GB
    },
    'gdrive': {
        'enabled': bool(getattr(config, 'GDRIVE_CREDENTIALS', None)),
        'client': None
    }
}

# Initialize Pyrogram Client
app = Client(
    "multi_cloud_bot",
    api_id=int(config.API_ID),
    api_hash=config.API_HASH,
    bot_token=config.BOT_TOKEN
)

# Thread pool for blocking operations
executor = ThreadPoolExecutor(max_workers=10)
loop = asyncio.get_event_loop()

# --- UTILITIES ---
def sizeof_fmt(num, suffix='B'):
    """Format file size into human-readable string."""
    for unit in ['', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)

def is_valid_url(url):
    """Check if URL is valid."""
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except:
        return False

def is_magnet_link(url):
    """Check if URL is a magnet link."""
    return url.startswith('magnet:')

def is_torrent_file(url):
    """Check if URL points to a torrent file."""
    return url.lower().endswith('.torrent')

def get_file_extension(filename):
    """Extract file extension."""
    return Path(filename).suffix.lower()

# --- DOWNLOAD MANAGERS ---
class YouTubeDLManager:
    """YouTube-DL download manager."""
    
    @staticmethod
    async def get_info(url):
        """Get video information."""
        def sync_get_info():
            ydl_opts = {'quiet': True, 'no_warnings': True}
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                return ydl.extract_info(url, download=False)
        
        return await loop.run_in_executor(executor, sync_get_info)
    
    @staticmethod
    async def download(url, quality='best', custom_path=None):
        """Download video/audio."""
        def sync_download():
            if custom_path:
                os.makedirs(custom_path, exist_ok=True)
            
            ydl_opts = {
                'outtmpl': os.path.join(custom_path or '', '%(title)s.%(ext)s'),
                'quiet': False,
            }
            
            if quality == 'audio':
                ydl_opts.update({
                    'format': 'bestaudio/best',
                    'postprocessors': [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': 'mp3',
                        'preferredquality': '192',
                    }],
                })
            else:
                ydl_opts['format'] = quality
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                return ydl.download([url])
        
        return await loop.run_in_executor(executor, sync_download)

class TorrentManager:
    """Torrent download manager."""
    
    def __init__(self):
        self.sessions = {}
        
    async def download_torrent(self, magnet_or_torrent, download_path, progress_callback=None):
        """Download torrent."""
        def sync_download():
            ses = lt.session()
            ses.listen_on(6881, 6891)
            
            if magnet_or_torrent.startswith('magnet:'):
                params = lt.parse_magnet_uri(magnet_or_torrent)
            else:
                # Handle torrent file
                info = lt.torrent_info(magnet_or_torrent)
                params = lt.add_torrent_params()
                params.ti = info
            
            params.save_path = download_path
            handle = ses.add_torrent(params)
            
            status = handle.status()
            while not status.is_seeding:
                status = handle.status()
                if progress_callback:
                    progress_callback(status)
                time.sleep(1)
            
            return download_path
        
        return await loop.run_in_executor(executor, sync_download)

class DirectDownloadManager:
    """Direct URL download manager."""
    
    @staticmethod
    async def download(url, download_path, progress_callback=None):
        """Download from direct URL."""
        def sync_download():
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0
            
            with open(download_path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        file.write(chunk)
                        downloaded_size += len(chunk)
                        if progress_callback:
                            progress_callback(downloaded_size, total_size)
            
            return download_path
        
        return await loop.run_in_executor(executor, sync_download)

# --- CLOUD STORAGE MANAGERS ---
class WasabiManager:
    """Wasabi cloud storage manager."""
    
    def __init__(self):
        if SUPPORTED_CLOUDS['wasabi']['enabled']:
            self.s3_config = Config(
                signature_version='s3v4',
                region_name=config.WASABI_REGION,
            )
            self.client = boto3.client(
                's3',
                aws_access_key_id=config.WASABI_ACCESS_KEY,
                aws_secret_access_key=config.WASABI_SECRET_KEY,
                endpoint_url=f"https://s3.{config.WASABI_REGION}.wasabisys.com",
                config=self.s3_config
            )
            self.bucket = config.WASABI_BUCKET
    
    async def upload_file(self, file_path, cloud_path=None, progress_callback=None):
        """Upload file to Wasabi."""
        if not self.client:
            raise Exception("Wasabi not configured")
        
        file_name = os.path.basename(file_path)
        cloud_key = cloud_path or f"uploads/{int(time.time())}_{file_name}"
        
        def sync_upload():
            self.client.upload_file(
                Filename=file_path,
                Bucket=self.bucket,
                Key=cloud_key,
                Callback=progress_callback
            )
            return cloud_key
        
        return await loop.run_in_executor(executor, sync_upload)
    
    async def generate_presigned_url(self, cloud_key, expires=600):
        """Generate presigned URL."""
        def sync_generate():
            return self.client.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.bucket, 'Key': cloud_key},
                ExpiresIn=expires
            )
        
        return await loop.run_in_executor(executor, sync_generate)

class TelegramManager:
    """Telegram cloud storage manager."""
    
    @staticmethod
    async def upload_file(client, chat_id, file_path, progress_callback=None, caption=""):
        """Upload file to Telegram."""
        file_size = os.path.getsize(file_path)
        
        if file_size > SUPPORTED_CLOUDS['telegram']['max_size']:
            raise Exception(f"File too large for Telegram. Max: {sizeof_fmt(SUPPORTED_CLOUDS['telegram']['max_size'])}")
        
        # Determine file type
        file_ext = get_file_extension(file_path)
        mime_type = "document"
        
        if file_ext in ['.mp4', '.avi', '.mkv', '.mov']:
            mime_type = "video"
        elif file_ext in ['.mp3', '.wav', '.flac', '.m4a']:
            mime_type = "audio"
        elif file_ext in ['.jpg', '.jpeg', '.png', '.gif']:
            mime_type = "photo"
        
        # Upload based on file type
        if mime_type == "video":
            message = await client.send_video(
                chat_id=chat_id,
                video=file_path,
                caption=caption,
                progress=progress_callback
            )
        elif mime_type == "audio":
            message = await client.send_audio(
                chat_id=chat_id,
                audio=file_path,
                caption=caption,
                progress=progress_callback
            )
        elif mime_type == "photo":
            message = await client.send_photo(
                chat_id=chat_id,
                photo=file_path,
                caption=caption,
                progress=progress_callback
            )
        else:
            message = await client.send_document(
                chat_id=chat_id,
                document=file_path,
                caption=caption,
                progress=progress_callback
            )
        
        return message

# Initialize managers
ytdl_manager = YouTubeDLManager()
torrent_manager = TorrentManager()
direct_manager = DirectDownloadManager()
wasabi_manager = WasabiManager()
telegram_manager = TelegramManager()

# --- PROGRESS HANDLING ---
def create_progress_callback(client, message, operation, file_name, file_size, start_time):
    """Create progress callback for various operations."""
    last_update_time = time.time()
    processed_bytes = 0
    
    async def update_progress(bytes_processed=0, total_bytes=0):
        nonlocal last_update_time, processed_bytes
        processed_bytes += bytes_processed
        
        current_time = time.time()
        
        if current_time - last_update_time >= 2:  # Update every 2 seconds
            try:
                time_elapsed = current_time - start_time
                speed = processed_bytes / time_elapsed if time_elapsed > 0 else 0
                percentage = (processed_bytes / (total_bytes or file_size)) * 100 if (total_bytes or file_size) else 0
                
                progress_bar_length = 10
                filled_length = int(progress_bar_length * percentage // 100)
                progress_bar = '‚ñà' * filled_length + '‚ñë' * (progress_bar_length - filled_length)
                
                status_text = (
                    f"**{operation}: {file_name}**\n\n"
                    f"`{progress_bar}` `{percentage:.1f}%`\n"
                    f"**Progress:** {sizeof_fmt(processed_bytes)} / {sizeof_fmt(total_bytes or file_size)}\n"
                    f"**Speed:** {sizeof_fmt(speed)}/s\n"
                    f"**Time:** {int(time_elapsed)}s"
                )
                
                await client.edit_message_text(
                    chat_id=message.chat.id,
                    message_id=message.id,
                    text=status_text
                )
                last_update_time = current_time
            except MessageNotModified:
                pass
            except Exception as e:
                logger.error(f"Progress update error: {e}")
    
    return update_progress

# --- TELEGRAM BOT HANDLERS ---
@app.on_message(filters.command("start") & filters.private)
async def start_handler(client: Client, message: Message):
    """Handle /start command."""
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìñ Help", callback_data="help"),
         InlineKeyboardButton("‚òÅÔ∏è Storage Info", callback_data="storage_info")],
        [InlineKeyboardButton("üîß Supported Sites", callback_data="supported_sites")]
    ])
    
    await message.reply_text(
        "üöÄ **Universal Download Bot**\n\n"
        "I can download from:\n"
        "‚Ä¢ üåê Direct URLs\n"
        "‚Ä¢ üì∫ YouTube/1000+ sites\n"
        "‚Ä¢ üß≤ Torrents & Magnet links\n"
        "‚Ä¢ üìÅ Telegram files\n\n"
        "And upload to:\n"
        "‚Ä¢ üì± Telegram Cloud\n"
        "‚Ä¢ ‚òÅÔ∏è Wasabi Storage\n\n"
        "**Commands:**\n"
        "‚Ä¢ /download <url> - Download from URL\n"
        "‚Ä¢ /torrent <magnet/torrent> - Download torrent\n"
        "‚Ä¢ /ytdl <url> - YouTube-DL download\n"
        "‚Ä¢ /upload - Upload replied file to cloud\n"
        "‚Ä¢ /help - Detailed help",
        reply_markup=keyboard
    )

@app.on_message(filters.command("download") & filters.private)
async def download_handler(client: Client, message: Message):
    """Handle direct download command."""
    if len(message.command) < 2:
        return await message.reply_text("Usage: /download <URL>")
    
    url = message.command[1]
    
    if not is_valid_url(url):
        return await message.reply_text("‚ùå Invalid URL")
    
    status_msg = await message.reply_text("üîÑ Analyzing URL...")
    
    try:
        # Get filename from URL
        parsed = urlparse(url)
        filename = os.path.basename(parsed.path) or f"download_{int(time.time())}"
        
        download_path = f"downloads/{filename}"
        os.makedirs("downloads", exist_ok=True)
        
        # Create progress callback
        start_time = time.time()
        progress_cb = create_progress_callback(
            client, status_msg, "Downloading", filename, 0, start_time
        )
        
        await status_msg.edit_text(f"üì• Downloading: `{filename}`")
        
        # Download file
        await direct_manager.download(url, download_path, progress_cb)
        
        file_size = os.path.getsize(download_path)
        
        # Ask user where to upload
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì± Telegram", callback_data=f"upload_telegram_{filename}"),
             InlineKeyboardButton("‚òÅÔ∏è Wasabi", callback_data=f"upload_wasabi_{filename}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_upload")]
        ])
        
        await status_msg.edit_text(
            f"‚úÖ Download Complete!\n"
            f"**File:** `{filename}`\n"
            f"**Size:** {sizeof_fmt(file_size)}\n\n"
            f"Where would you like to upload?",
            reply_markup=keyboard
        )
        
    except Exception as e:
        logger.exception("Download error")
        await status_msg.edit_text(f"‚ùå Download failed: {str(e)}")

@app.on_message(filters.command("ytdl") & filters.private)
async def ytdl_handler(client: Client, message: Message):
    """Handle YouTube-DL downloads."""
    if len(message.command) < 2:
        return await message.reply_text("Usage: /ytdl <URL> [quality]\n\nQuality options: best, 720p, 480p, audio")
    
    url = message.command[1]
    quality = message.command[2] if len(message.command) > 2 else "best"
    
    status_msg = await message.reply_text("üîç Fetching video info...")
    
    try:
        # Get video info
        info = await ytdl_manager.get_info(url)
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üé• Video", callback_data=f"ytdl_{quality}_{url}"),
             InlineKeyboardButton("üéµ Audio Only", callback_data=f"ytdl_audio_{url}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel")]
        ])
        
        await status_msg.edit_text(
            f"üé¨ **{info.get('title', 'Unknown')}**\n"
            f"‚è± Duration: {info.get('duration', 'Unknown')}s\n"
            f"üìä Quality: {quality}\n\n"
            f"Choose download type:",
            reply_markup=keyboard
        )
        
    except Exception as e:
        await status_msg.edit_text(f"‚ùå Failed to get video info: {str(e)}")

@app.on_message(filters.command("torrent") & filters.private)
async def torrent_handler(client: Client, message: Message):
    """Handle torrent downloads."""
    if len(message.command) < 2:
        return await message.reply_text("Usage: /torrent <magnet_link_or_torrent_url>")
    
    torrent_input = message.command[1]
    
    if not (is_magnet_link(torrent_input) or is_torrent_file(torrent_input)):
        return await message.reply_text("‚ùå Please provide a valid magnet link or .torrent URL")
    
    status_msg = await message.reply_text("üß≤ Initializing torrent download...")
    
    try:
        download_path = f"torrents/{int(time.time())}"
        os.makedirs(download_path, exist_ok=True)
        
        await status_msg.edit_text("üì• Downloading torrent...")
        
        # Download torrent (simplified - in production you'd want more control)
        result_path = await torrent_manager.download_torrent(
            torrent_input, 
            download_path
        )
        
        await status_msg.edit_text(
            f"‚úÖ Torrent download completed!\n"
            f"**Path:** `{result_path}`\n\n"
            f"Use /upload to upload files to cloud storage."
        )
        
    except Exception as e:
        logger.exception("Torrent error")
        await status_msg.edit_text(f"‚ùå Torrent download failed: {str(e)}")

@app.on_callback_query()
async def callback_handler(client: Client, callback_query):
    """Handle inline keyboard callbacks."""
    data = callback_query.data
    message = callback_query.message
    
    if data == "help":
        await callback_query.answer()
        await message.edit_text(
            "üìñ **Bot Help**\n\n"
            "**Download Commands:**\n"
            "‚Ä¢ `/download <url>` - Direct download\n"
            "‚Ä¢ `/ytdl <url> [quality]` - YouTube/1000+ sites\n"
            "‚Ä¢ `/torrent <magnet/torrent>` - Torrent download\n"
            "‚Ä¢ `/upload` - Upload replied file\n\n"
            "**Quality options for ytdl:**\n"
            "‚Ä¢ `best` - Best quality\n"
            "‚Ä¢ `720p`, `480p` - Specific resolution\n"
            "‚Ä¢ `audio` - Audio only\n\n"
            "**Supported sites:** YouTube, Vimeo, Twitter, TikTok, Instagram, 1000+ more!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back", callback_data="back_to_start")]
            ])
        )
    
    elif data.startswith("ytdl_"):
        await callback_query.answer("Starting download...")
        parts = data.split("_")
        quality = parts[1]
        url = "_".join(parts[2:])
        
        await handle_ytdl_download(client, message, url, quality)
    
    elif data.startswith("upload_"):
        await handle_upload_callback(client, callback_query, data)
    
    elif data == "back_to_start":
        await start_handler(client, message)
    
    elif data == "cancel":
        await message.edit_text("‚ùå Operation cancelled.")

async def handle_ytdl_download(client, message, url, quality):
    """Handle YouTube-DL download from callback."""
    try:
        await message.edit_text("üîÑ Starting download...")
        
        download_path = f"ytdl_downloads/{int(time.time())}"
        os.makedirs(download_path, exist_ok=True)
        
        await ytdl_manager.download(url, quality, download_path)
        
        # Find downloaded file
        files = list(Path(download_path).glob("*"))
        if files:
            downloaded_file = files[0]
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üì± Telegram", callback_data=f"upload_telegram_{downloaded_file.name}"),
                 InlineKeyboardButton("‚òÅÔ∏è Wasabi", callback_data=f"upload_wasabi_{downloaded_file.name}")]
            ])
            
            await message.edit_text(
                f"‚úÖ Download Complete!\n"
                f"**File:** `{downloaded_file.name}`\n\n"
                f"Choose upload destination:",
                reply_markup=keyboard
            )
        else:
            await message.edit_text("‚ùå No files downloaded")
            
    except Exception as e:
        await message.edit_text(f"‚ùå Download failed: {str(e)}")

async def handle_upload_callback(client, callback_query, data):
    """Handle upload destination selection."""
    parts = data.split("_")
    service = parts[1]
    filename = "_".join(parts[2:])
    
    await callback_query.answer(f"Uploading to {service}...")
    
    try:
        file_path = f"downloads/{filename}"
        if not os.path.exists(file_path):
            # Search in other directories
            for dir_path in ["downloads", "ytdl_downloads", "torrents"]:
                potential_path = f"{dir_path}/{filename}"
                if os.path.exists(potential_path):
                    file_path = potential_path
                    break
        
        if not os.path.exists(file_path):
            raise Exception("File not found")
        
        file_size = os.path.getsize(file_path)
        
        if service == "telegram":
            await callback_query.message.edit_text("üì§ Uploading to Telegram...")
            
            start_time = time.time()
            progress_cb = create_progress_callback(
                client, callback_query.message, "Uploading to Telegram", 
                filename, file_size, start_time
            )
            
            await telegram_manager.upload_file(
                client, 
                callback_query.message.chat.id,
                file_path,
                progress_cb,
                f"Uploaded by Universal Download Bot"
            )
            
            await callback_query.message.edit_text("‚úÖ Uploaded to Telegram successfully!")
            
        elif service == "wasabi" and SUPPORTED_CLOUDS['wasabi']['enabled']:
            await callback_query.message.edit_text("‚òÅÔ∏è Uploading to Wasabi...")
            
            start_time = time.time()
            progress_cb = create_progress_callback(
                client, callback_query.message, "Uploading to Wasabi",
                filename, file_size, start_time
            )
            
            cloud_key = await wasabi_manager.upload_file(
                file_path,
                progress_callback=progress_cb
            )
            
            download_url = await wasabi_manager.generate_presigned_url(cloud_key)
            
            await callback_query.message.edit_text(
                f"‚úÖ Uploaded to Wasabi!\n\n"
                f"**File:** `{filename}`\n"
                f"**Cloud Path:** `{cloud_key}`\n"
                f"**Download URL:** [Click Here]({download_url})\n\n"
                f"*Link expires in 10 minutes*",
                disable_web_page_preview=True
            )
        
        # Clean up local file
        os.remove(file_path)
        
    except Exception as e:
        logger.exception("Upload error")
        await callback_query.message.edit_text(f"‚ùå Upload failed: {str(e)}")

# --- MAIN EXECUTION ---
if __name__ == "__main__":
    logger.info("Universal Download Bot starting...")
    
    # Create necessary directories
    for directory in ["downloads", "ytdl_downloads", "torrents"]:
        os.makedirs(directory, exist_ok=True)
    
    try:
        app.run()
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.exception("Bot crashed")
    finally:
        executor.shutdown(wait=True)
        logger.info("Bot shutdown complete")
